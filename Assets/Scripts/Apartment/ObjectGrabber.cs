using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.Rendering;

public class ObjectGrabber : MonoBehaviour
{
    [Header("Physics")]
    [Tooltip("Spring strength pulling the object toward the cursor.")]
    [SerializeField] private float grabSpring = 120f;

    [Tooltip("Damper opposing overshoot.")]
    [SerializeField] private float grabDamper = 18f;

    [Tooltip("Maximum acceleration applied to the grabbed object.")]
    [SerializeField] private float maxAccel = 60f;

    [Tooltip("Maximum speed cap to prevent tunneling.")]
    [SerializeField] private float maxSpeed = 12f;

    [Header("Grid Snap")]
    [Tooltip("Grid cell size in world units.")]
    [SerializeField] private float gridSize = 0.3f;

    public float GridSize
    {
        get => gridSize;
        set => gridSize = Mathf.Max(0.01f, value);
    }

    [Header("Scroll Behavior")]
    [Tooltip("Degrees rotated per scroll tick around Y axis.")]
    [SerializeField] private float scrollRotateStep = 45f;

    [Header("Raycast")]
    [Tooltip("Layer mask for placeable objects.")]
    [SerializeField] private LayerMask placeableLayer = ~0;

    [Tooltip("Layer mask for surface triggers (auto-generated by PlacementSurface).")]
    [SerializeField] private LayerMask surfaceLayer;

    [Tooltip("Camera used for raycasting. Auto-finds MainCamera if null.")]
    [SerializeField] private Camera cam;

    [Header("Audio")]
    [Tooltip("SFX played when picking up an object.")]
    [SerializeField] private AudioClip _pickupSFX;

    [Tooltip("SFX played when placing an object on a surface.")]
    [SerializeField] private AudioClip _placeSFX;

    [Header("Tether")]
    [Tooltip("Max distance between grab target and held object before teleporting to catch up.")]
    [SerializeField] private float maxTetherDistance = 3f;

    // Inline InputActions
    private InputAction _mousePosition;
    private InputAction _mouseClick;
    private InputAction _gridToggle;
    private InputAction _scrollAction;

    private bool _isEnabled;
    private bool _gridSnap;

    /// <summary>Fired after an object is placed on a surface.</summary>
    public static event System.Action OnObjectPlaced;

    private static ObjectGrabber s_instance;

    /// <summary>True when any ObjectGrabber is holding an object. Check this to block other interactions.</summary>
    public static bool IsHoldingObject => s_instance != null && s_instance._held != null;

    /// <summary>The currently held PlaceableObject, or null if nothing is held.</summary>
    public static PlaceableObject HeldObject => s_instance != null ? s_instance._held : null;

    private PlaceableObject _held;
    private Rigidbody _heldRb;
    private Vector3 _grabTarget;
    private float _fallbackDepth;
    private RigidbodyConstraints _originalConstraints;

    // Surface tracking
    private PlacementSurface _currentSurface;
    private PlacementSurface _lastValidSurface;
    private float _wallRotation;
    private bool _isOnWall;

    // Double-click detection for plate unstacking
    private float _lastClickTime;
    private const float DoubleClickThreshold = 0.3f;

    // Shadow preview
    private GameObject _shadowGO;
    private MeshRenderer _shadowRenderer;
    private Material _shadowMat;
    private static readonly Color s_shadowValid = new Color(0.55f, 0.7f, 0.55f, 0.7f);
    private static readonly Color s_shadowInvalid = new Color(0.72f, 0.45f, 0.48f, 0.7f);

    private void Awake()
    {
        s_instance = this;

        if (cam == null)
            cam = Camera.main;

        _mousePosition = new InputAction("MousePos", InputActionType.Value, "<Mouse>/position");
        _mouseClick = new InputAction("MouseClick", InputActionType.Button, "<Mouse>/leftButton");
        _gridToggle = new InputAction("GridToggle", InputActionType.Button, "<Keyboard>/g");
        _scrollAction = new InputAction("Scroll", InputActionType.Value, "<Mouse>/scroll/y");

        BuildShadow();
    }

    private void OnEnable()
    {
        _mousePosition.Enable();
        _mouseClick.Enable();
        _gridToggle.Enable();
        _scrollAction.Enable();
    }

    private void OnDisable()
    {
        _mousePosition.Disable();
        _mouseClick.Disable();
        _gridToggle.Disable();
        _scrollAction.Disable();
    }

    private void OnDestroy()
    {
        if (s_instance == this) s_instance = null;
        if (_shadowMat != null) Destroy(_shadowMat);
    }

    private void Update()
    {
        if (DayPhaseManager.Instance != null && !DayPhaseManager.Instance.IsInteractionPhase)
            return;

        if (!_isEnabled) return;

        if (_gridToggle.WasPressedThisFrame())
        {
            _gridSnap = !_gridSnap;
            Debug.Log($"[ObjectGrabber] Grid snap: {(_gridSnap ? "ON" : "OFF")}");
        }

        if (_mouseClick.WasPressedThisFrame())
        {
            if (_held == null)
            {
                TryPickUp();
            }
            else
            {
                // Double-click while holding a plate stack → unstack top plate
                float now = Time.unscaledTime;
                bool isDoubleClick = (now - _lastClickTime) < DoubleClickThreshold;
                _lastClickTime = now;

                if (isDoubleClick && TryUnstackHeldPlate())
                    return;

                // If holding a plate, check if clicking another plate → join stack
                if (TryStackOntoClickedPlate())
                    return;

                Place();
            }
        }

        if (_held != null)
        {
            UpdateGrabTarget();
            UpdateScrollInput();
            UpdateShadow();
        }
    }

    private void FixedUpdate()
    {
        if (_held == null || _heldRb == null) return;

        // Tether snap-back
        if (Vector3.Distance(_heldRb.position, _grabTarget) > maxTetherDistance)
        {
            _heldRb.position = _grabTarget;
            _heldRb.linearVelocity = Vector3.zero;
        }

        // Spring-damper pull
        Vector3 toTarget = _grabTarget - _heldRb.worldCenterOfMass;
        Vector3 accel = toTarget * grabSpring - _heldRb.linearVelocity * grabDamper;

        if (accel.sqrMagnitude > maxAccel * maxAccel)
            accel = accel.normalized * maxAccel;

        _heldRb.AddForce(accel, ForceMode.Acceleration);

        // Speed cap
        if (_heldRb.linearVelocity.sqrMagnitude > maxSpeed * maxSpeed)
            _heldRb.linearVelocity = _heldRb.linearVelocity.normalized * maxSpeed;
    }

    // ── Pick up ──────────────────────────────────────────────────────

    private void TryPickUp()
    {
        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        if (!Physics.Raycast(ray, out RaycastHit hit, 100f, placeableLayer))
            return;

        var placeable = hit.collider.GetComponent<PlaceableObject>();
        if (placeable == null)
            placeable = hit.collider.GetComponentInParent<PlaceableObject>();

        if (placeable == null || placeable.CurrentState == PlaceableObject.State.Held)
            return;

        _held = placeable;

        // Detach from plate stack before pickup
        var stackable = placeable.GetComponent<StackablePlate>();
        if (stackable != null)
            stackable.PrepareForGrab();

        _heldRb = placeable.GetComponent<Rigidbody>();
        _heldRb.useGravity = false;
        _heldRb.isKinematic = false;
        _grabTarget = _heldRb.worldCenterOfMass;

        // Store depth for floating fallback when cursor isn't over a surface
        _fallbackDepth = Vector3.Dot(
            _heldRb.worldCenterOfMass - cam.transform.position,
            cam.transform.forward);

        // Lock rotation so collisions don't spin the object
        _originalConstraints = _heldRb.constraints;
        _heldRb.constraints = _originalConstraints | RigidbodyConstraints.FreezeRotation;

        _currentSurface = placeable.LastPlacedSurface;
        _lastValidSurface = _currentSurface;
        _wallRotation = 0f;
        _isOnWall = false;

        placeable.OnPickedUp();

        // Book hidden item check
        var bookItem = placeable.GetComponent<BookItem>();
        if (bookItem != null) bookItem.OnBookPickedUp();

        AudioManager.Instance?.PlaySFX(_pickupSFX);
        ShowShadow(true);

        // Show pickup description
        if (PickupDescriptionHUD.Instance != null)
            PickupDescriptionHUD.Instance.Show(placeable.ItemDescription);
    }

    // ── Place ────────────────────────────────────────────────────────

    private void Place()
    {
        if (_held == null) return;

        // Must be over a surface to place
        if (_currentSurface == null) return;

        // ── Drawer storage check ──
        // If surface is child of an open drawer with capacity, store the item
        var drawer = _currentSurface.GetComponentInParent<DrawerController>();
        if (drawer != null && drawer.CurrentState == DrawerController.State.Open && drawer.HasCapacity)
        {
            _heldRb.constraints = _originalConstraints;
            _heldRb.linearVelocity = Vector3.zero;
            drawer.StoreItem(_held);
            ClearHeld();
            return;
        }

        // ── DropZone check ──
        // If surface has a DropZone matching the held item's home zone, route through it
        if (!string.IsNullOrEmpty(_held.HomeZoneName))
        {
            var zone = _currentSurface.GetComponent<DropZone>();
            if (zone != null && zone.ZoneName == _held.HomeZoneName)
            {
                _heldRb.constraints = _originalConstraints;
                _heldRb.linearVelocity = Vector3.zero;

                if (zone.DestroyOnDeposit)
                {
                    // Trash can — shrink and destroy
                    zone.RegisterDeposit(_held);
                    ClearHeld();
                    return;
                }
                // Normal drop zone — place normally, zone registers deposit
                // Fall through to standard placement, OnPlaced will set IsAtHome
            }
        }

        // Wall items only on walls, table items only on tables
        if (_currentSurface.IsVertical && !_held.CanWallMount) return;
        if (!_currentSurface.IsVertical && _held.WallOnly) return;

        // Use _grabTarget (cursor-tracked) instead of _heldRb.position for wall face
        // detection — the rigidbody can overshoot through thin wall triggers.
        var hitResult = _currentSurface.ProjectOntoSurface(_grabTarget);
        Vector3 pos = _gridSnap
            ? _currentSurface.SnapToGrid(hitResult.worldPosition, gridSize)
            : hitResult.worldPosition;

        float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
        pos += hitResult.surfaceNormal * halfExtent;

        Quaternion rot;
        if (_currentSurface.IsVertical)
        {
            rot = Quaternion.LookRotation(hitResult.surfaceNormal, Vector3.up)
                * Quaternion.AngleAxis(_wallRotation, Vector3.forward);
        }
        else
        {
            rot = _held.transform.rotation;
        }

        // Restore constraints before placement configures the rigidbody
        _heldRb.constraints = _originalConstraints;
        _heldRb.linearVelocity = Vector3.zero;

        _held.OnPlaced(_currentSurface, _gridSnap, pos, rot);
        OnObjectPlaced?.Invoke();
        AudioManager.Instance?.PlaySFX(_placeSFX);

        // DropZone deposit (non-destroy — item stays placed on surface)
        if (!string.IsNullOrEmpty(_held.HomeZoneName))
        {
            var zone = _currentSurface.GetComponent<DropZone>();
            if (zone != null && zone.ZoneName == _held.HomeZoneName)
                zone.RegisterDeposit(_held);
        }

        // Stack-aware plate hooks
        var stackable = _held.GetComponent<StackablePlate>();
        if (stackable != null)
        {
            stackable.TryJoinStack();
            var dishZone = _currentSurface != null
                ? _currentSurface.GetComponent<DishDropZone>() : null;
            if (dishZone != null)
            {
                // Deposit the held plate plus any child plates in the stack
                dishZone.RegisterDeposit(stackable);
                var childPlates = stackable.GetComponentsInChildren<StackablePlate>();
                foreach (var child in childPlates)
                {
                    if (child != stackable)
                        dishZone.RegisterDeposit(child);
                }
            }
        }

        ClearHeld();
    }

    // ── Plate stacking helpers ─────────────────────────────────────

    /// <summary>
    /// While holding a plate, raycast for another plate under the cursor.
    /// If found, join the clicked plate onto the held stack (or vice versa).
    /// </summary>
    private bool TryStackOntoClickedPlate()
    {
        var heldStack = _held.GetComponent<StackablePlate>();
        if (heldStack == null) return false;

        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        if (!Physics.Raycast(ray, out RaycastHit hit, 100f, placeableLayer))
            return false;

        var clickedPlate = hit.collider.GetComponent<StackablePlate>();
        if (clickedPlate == null)
            clickedPlate = hit.collider.GetComponentInParent<StackablePlate>();
        if (clickedPlate == null || clickedPlate == heldStack) return false;
        if (clickedPlate.transform.IsChildOf(_held.transform)) return false;

        // Detach the clicked plate from its current context and parent to held plate
        clickedPlate.PrepareForGrab();
        clickedPlate.transform.SetParent(_held.transform);
        clickedPlate.transform.localPosition = new Vector3(0f, 0.03f * GetStackCount(_held.transform), 0f);
        clickedPlate.transform.localRotation = Quaternion.identity;

        var clickedRb = clickedPlate.GetComponent<Rigidbody>();
        if (clickedRb != null)
        {
            clickedRb.isKinematic = true;
            clickedRb.linearVelocity = Vector3.zero;
        }

        var clickedPlaceable = clickedPlate.GetComponent<PlaceableObject>();
        if (clickedPlaceable != null)
            clickedPlaceable.OnPickedUp();

        Debug.Log($"[ObjectGrabber] Stacked {clickedPlate.name} onto held {_held.name}");
        return true;
    }

    /// <summary>
    /// Double-click while holding a plate with children → detach the topmost child
    /// and place/drop the remaining stack.
    /// </summary>
    private bool TryUnstackHeldPlate()
    {
        var heldStack = _held.GetComponent<StackablePlate>();
        if (heldStack == null) return false;

        // Find topmost child plate
        StackablePlate topChild = null;
        foreach (Transform child in _held.transform)
        {
            var sp = child.GetComponent<StackablePlate>();
            if (sp != null)
                topChild = sp;
        }
        if (topChild == null) return false;

        // Detach the top plate — it becomes the new held object
        topChild.PrepareForGrab();

        // Drop the current stack onto the nearest surface
        _heldRb.constraints = _originalConstraints;
        _heldRb.linearVelocity = Vector3.zero;
        _heldRb.useGravity = true;
        _held.OnDropped();

        // Pick up the detached top plate
        var oldHeld = _held;
        _held = topChild.GetComponent<PlaceableObject>();
        _heldRb = topChild.GetComponent<Rigidbody>();
        if (_heldRb != null)
        {
            _heldRb.useGravity = false;
            _heldRb.isKinematic = false;
            _grabTarget = _heldRb.worldCenterOfMass;
            _originalConstraints = _heldRb.constraints;
            _heldRb.constraints = _originalConstraints | RigidbodyConstraints.FreezeRotation;
        }
        _held.OnPickedUp();

        Debug.Log($"[ObjectGrabber] Unstacked {topChild.name} from {oldHeld.name}");
        return true;
    }

    private static int GetStackCount(Transform root)
    {
        int count = 0;
        foreach (Transform child in root)
        {
            if (child.GetComponent<StackablePlate>() != null)
                count++;
        }
        return count;
    }

    private void ClearHeld()
    {
        _held = null;
        _heldRb = null;
        _currentSurface = null;
        _lastValidSurface = null;
        _isOnWall = false;
        ShowShadow(false);

        if (PickupDescriptionHUD.Instance != null)
            PickupDescriptionHUD.Instance.Hide();
    }

    // ── Grab target (surface raycast with depth-plane fallback) ──────

    private void UpdateGrabTarget()
    {
        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        // During dolly animation, keep object on screen-space depth plane
        // so it travels with the cursor instead of clinging to the old room
        bool dollying = ApartmentManager.Instance != null && ApartmentManager.Instance.IsTransitioning;

        if (!dollying && Physics.Raycast(ray, out RaycastHit hit, 100f, surfaceLayer))
        {
            var surface = hit.collider.GetComponentInParent<PlacementSurface>();
            bool surfaceValid = surface != null
                && (!surface.IsVertical || _held.CanWallMount)
                && (surface.IsVertical || !_held.WallOnly);
            if (surfaceValid)
            {
                _currentSurface = surface;
                _lastValidSurface = surface;
                _isOnWall = surface.IsVertical;

                var hitResult = surface.ProjectOntoSurface(hit.point);
                Vector3 pos = _gridSnap
                    ? surface.SnapToGrid(hitResult.worldPosition, gridSize)
                    : hitResult.worldPosition;

                float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
                pos += hitResult.surfaceNormal * halfExtent;

                _grabTarget = pos;

                // Track depth so fallback stays smooth if cursor leaves surface
                _fallbackDepth = Vector3.Dot(
                    _grabTarget - cam.transform.position,
                    cam.transform.forward);

                if (_isOnWall)
                    _held.AlignToWall(hitResult.surfaceNormal, _wallRotation);

                return;
            }
        }

        // No valid surface or dollying — float at fallback depth following cursor
        _currentSurface = null;
        _isOnWall = false;

        Vector3 planePoint = cam.transform.position + cam.transform.forward * _fallbackDepth;
        var plane = new Plane(-cam.transform.forward, planePoint);
        if (plane.Raycast(ray, out float enter))
            _grabTarget = ray.GetPoint(enter);
    }

    // ── Scroll input ─────────────────────────────────────────────────

    private void UpdateScrollInput()
    {
        float scroll = _scrollAction.ReadValue<float>();
        if (Mathf.Abs(scroll) < 0.01f) return;

        float angle = scrollRotateStep * Mathf.Sign(scroll);

        if (_isOnWall)
        {
            // Wall items: rotate around surface normal (forward axis)
            _wallRotation += angle;
        }
        else
        {
            // Table items: rotate around Y axis
            // Transform.Rotate bypasses FreezeRotation constraints
            _held.transform.Rotate(0f, angle, 0f, Space.World);
        }
    }

    // ── Helper: half-extent along a normal ────────────────────────────

    private const float PlacementSafetyMargin = 0.02f;

    private float GetHeldHalfExtentAlongNormal(Vector3 normal)
    {
        var col = _held.GetComponent<Collider>();
        if (col == null) return 0f;

        Vector3 extents = col.bounds.extents;
        return Mathf.Abs(Vector3.Dot(extents, normal.normalized)) + PlacementSafetyMargin;
    }

    // ── Shadow preview ──────────────────────────────────────────────

    private void BuildShadow()
    {
        _shadowGO = new GameObject("PlacementShadow");
        _shadowGO.transform.SetParent(transform);

        var mf = _shadowGO.AddComponent<MeshFilter>();
        _shadowRenderer = _shadowGO.AddComponent<MeshRenderer>();

        var mesh = new Mesh { name = "ShadowQuad" };
        mesh.vertices = new[]
        {
            new Vector3(-0.5f, 0f, -0.5f),
            new Vector3( 0.5f, 0f, -0.5f),
            new Vector3( 0.5f, 0f,  0.5f),
            new Vector3(-0.5f, 0f,  0.5f)
        };
        mesh.uv = new[]
        {
            new Vector2(0f, 0f), new Vector2(1f, 0f),
            new Vector2(1f, 1f), new Vector2(0f, 1f)
        };
        mesh.triangles = new[] { 0, 2, 1, 0, 3, 2 };
        mesh.RecalculateNormals();
        mf.sharedMesh = mesh;

        int texSize = 32;
        var tex = new Texture2D(texSize, texSize, TextureFormat.RGBA32, false);
        tex.filterMode = FilterMode.Bilinear;
        tex.wrapMode = TextureWrapMode.Clamp;
        float center = texSize * 0.5f;
        float radius = center - 1f;
        for (int y = 0; y < texSize; y++)
        {
            for (int x = 0; x < texSize; x++)
            {
                float dist = Vector2.Distance(new Vector2(x, y), new Vector2(center, center));
                float a = Mathf.Clamp01((radius - dist) / 2f);
                tex.SetPixel(x, y, new Color(1f, 1f, 1f, a));
            }
        }
        tex.Apply();

        var shader = Shader.Find("Universal Render Pipeline/Particles/Unlit");
        if (shader == null) shader = Shader.Find("Sprites/Default");
        if (shader == null) shader = Shader.Find("Unlit/Transparent");
        _shadowMat = new Material(shader);
        _shadowMat.mainTexture = tex;
        _shadowMat.color = s_shadowValid;
        _shadowMat.SetFloat("_Surface", 1f);
        _shadowMat.SetFloat("_Blend", 0f);
        _shadowMat.SetInt("_ZTest", (int)CompareFunction.Always);
        _shadowMat.renderQueue = 3900;
        _shadowRenderer.sharedMaterial = _shadowMat;
        _shadowRenderer.shadowCastingMode = ShadowCastingMode.Off;
        _shadowRenderer.receiveShadows = false;

        _shadowGO.SetActive(false);
    }

    private void ShowShadow(bool show)
    {
        if (_shadowGO != null)
            _shadowGO.SetActive(show);
    }

    private void UpdateShadow()
    {
        if (_shadowGO == null || _heldRb == null) return;

        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        bool valid = false;
        Vector3 shadowPos = _heldRb.position + Vector3.down * 0.5f;
        Quaternion shadowRot = Quaternion.identity;

        if (Physics.Raycast(ray, out RaycastHit hit, 100f, surfaceLayer))
        {
            var surface = hit.collider.GetComponentInParent<PlacementSurface>();
            if (surface != null)
            {
                bool canPlace = (!surface.IsVertical || _held.CanWallMount)
                    && (surface.IsVertical || !_held.WallOnly);
                var hitResult = surface.ProjectOntoSurface(hit.point);
                shadowPos = hitResult.worldPosition + hitResult.surfaceNormal * 0.01f;
                shadowRot = Quaternion.FromToRotation(Vector3.up, hitResult.surfaceNormal);
                valid = canPlace;
            }
        }

        _shadowMat.color = valid ? s_shadowValid : s_shadowInvalid;
        _shadowGO.transform.position = shadowPos;
        _shadowGO.transform.rotation = shadowRot;

        var col = _held.GetComponent<Collider>();
        if (col != null)
        {
            Vector3 ext = col.bounds.extents;
            float diameter = Mathf.Max(ext.x, ext.z) * 2f * 1.3f; // 30% larger than footprint
            _shadowGO.transform.localScale = new Vector3(diameter, 1f, diameter);
        }
    }

    // ── Public API ──────────────────────────────────────────────────

    /// <summary>
    /// Enable or disable grabbing. Called by ApartmentManager during state transitions.
    /// When disabled while holding, forces a drop onto the nearest surface.
    /// </summary>
    public void SetEnabled(bool enabled)
    {
        _isEnabled = enabled;

        if (!enabled && _held != null)
        {
            // Restore rotation constraints before configuring rigidbody
            _heldRb.constraints = _originalConstraints;

            var nearest = FindNearestSurfaceForHeld(_heldRb.position);
            if (nearest != null)
            {
                var hitResult = nearest.ProjectOntoSurface(_heldRb.position);
                float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
                Vector3 pos = hitResult.worldPosition + hitResult.surfaceNormal * halfExtent;
                Quaternion rot = nearest.IsVertical
                    ? Quaternion.LookRotation(hitResult.surfaceNormal, Vector3.up)
                    : _held.transform.rotation;

                _heldRb.linearVelocity = Vector3.zero;
                _held.OnPlaced(nearest, false, pos, rot);

                // Stack-aware plate hooks on force-drop
                var stackable = _held.GetComponent<StackablePlate>();
                if (stackable != null)
                {
                    stackable.TryJoinStack();
                    var dropZone = nearest.GetComponent<DishDropZone>();
                    if (dropZone != null)
                    {
                        dropZone.RegisterDeposit(stackable);
                        var childPlates = stackable.GetComponentsInChildren<StackablePlate>();
                        foreach (var child in childPlates)
                        {
                            if (child != stackable)
                                dropZone.RegisterDeposit(child);
                        }
                    }
                }
            }
            else
            {
                _heldRb.useGravity = true;
                _heldRb.linearVelocity = Vector3.zero;
                _held.OnDropped();
            }

            ClearHeld();
        }
    }

    private PlacementSurface FindNearestSurfaceForHeld(Vector3 worldPos)
    {
        if (_held == null) return PlacementSurface.FindNearest(worldPos);
        return PlacementSurface.FindNearest(worldPos,
            skipVertical: !_held.CanWallMount,
            skipHorizontal: _held.WallOnly);
    }
}
