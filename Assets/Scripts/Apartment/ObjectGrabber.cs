using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.Rendering;

public class ObjectGrabber : MonoBehaviour
{
    [Header("Physics")]
    [Tooltip("Spring strength pulling the object toward the cursor.")]
    [SerializeField] private float grabSpring = 120f;

    [Tooltip("Damper opposing overshoot.")]
    [SerializeField] private float grabDamper = 18f;

    [Tooltip("Maximum acceleration applied to the grabbed object.")]
    [SerializeField] private float maxAccel = 60f;

    [Tooltip("Maximum speed cap to prevent tunneling.")]
    [SerializeField] private float maxSpeed = 12f;

    [Header("Grid Snap")]
    [Tooltip("Grid cell size in world units.")]
    [SerializeField] private float gridSize = 0.2f;

    [Header("Scroll Behavior")]
    [Tooltip("Degrees rotated per scroll tick.")]
    [SerializeField] private float rotationStep = 15f;

    [Header("Raycast")]
    [Tooltip("Layer mask for placeable objects.")]
    [SerializeField] private LayerMask placeableLayer = ~0;

    [Tooltip("Layer mask for surface triggers (auto-generated by PlacementSurface).")]
    [SerializeField] private LayerMask surfaceLayer;

    [Tooltip("Camera used for raycasting. Auto-finds MainCamera if null.")]
    [SerializeField] private Camera cam;

    [Header("Tether")]
    [Tooltip("Max distance between grab target and held object before teleporting to catch up.")]
    [SerializeField] private float maxTetherDistance = 3f;

    // Inline InputActions
    private InputAction _mousePosition;
    private InputAction _mouseClick;
    private InputAction _gridToggle;
    private InputAction _scrollAction;

    private bool _isEnabled;
    private bool _gridSnap;

    private PlaceableObject _held;
    private Rigidbody _heldRb;
    private Vector3 _grabTarget;

    // Surface tracking
    private PlacementSurface _currentSurface;
    private PlacementSurface _lastValidSurface;
    private float _wallRotation;
    private bool _isOnWall;

    // Shadow preview
    private GameObject _shadowGO;
    private MeshRenderer _shadowRenderer;
    private Material _shadowMat;
    private static readonly Color s_shadowValid = new Color(0.2f, 0.8f, 0.3f, 0.5f);
    private static readonly Color s_shadowInvalid = new Color(0.8f, 0.2f, 0.2f, 0.5f);

    private void Awake()
    {
        if (cam == null)
            cam = Camera.main;

        _mousePosition = new InputAction("MousePos", InputActionType.Value, "<Mouse>/position");
        _mouseClick = new InputAction("MouseClick", InputActionType.Button, "<Mouse>/leftButton");
        _gridToggle = new InputAction("GridToggle", InputActionType.Button, "<Keyboard>/g");
        _scrollAction = new InputAction("Scroll", InputActionType.Value, "<Mouse>/scroll/y");

        BuildShadow();
    }

    private void OnEnable()
    {
        _mousePosition.Enable();
        _mouseClick.Enable();
        _gridToggle.Enable();
        _scrollAction.Enable();
    }

    private void OnDisable()
    {
        _mousePosition.Disable();
        _mouseClick.Disable();
        _gridToggle.Disable();
        _scrollAction.Disable();
    }

    private void OnDestroy()
    {
        if (_shadowMat != null) Destroy(_shadowMat);
    }

    private void Update()
    {
        if (!_isEnabled) return;

        // Toggle grid snap
        if (_gridToggle.WasPressedThisFrame())
        {
            _gridSnap = !_gridSnap;
            Debug.Log($"[ObjectGrabber] Grid snap: {(_gridSnap ? "ON" : "OFF")}");
        }

        if (_mouseClick.WasPressedThisFrame())
        {
            if (_held == null)
                TryPickUp();
            else
                Place();
        }

        // Update grab target, scroll input, and shadow while holding
        if (_held != null)
        {
            UpdateGrabTarget();
            UpdateScrollInput();
            UpdateShadow();
        }
    }

    private void FixedUpdate()
    {
        if (_held == null || _heldRb == null) return;

        // Tether snap-back: teleport if too far from grab target
        if (Vector3.Distance(_heldRb.position, _grabTarget) > maxTetherDistance)
        {
            _heldRb.position = _grabTarget;
            _heldRb.linearVelocity = Vector3.zero;
        }

        // Spring-damper pull
        Vector3 toTarget = _grabTarget - _heldRb.worldCenterOfMass;
        Vector3 accel = toTarget * grabSpring - _heldRb.linearVelocity * grabDamper;

        if (accel.sqrMagnitude > maxAccel * maxAccel)
            accel = accel.normalized * maxAccel;

        _heldRb.AddForce(accel, ForceMode.Acceleration);

        // Speed cap
        if (_heldRb.linearVelocity.sqrMagnitude > maxSpeed * maxSpeed)
            _heldRb.linearVelocity = _heldRb.linearVelocity.normalized * maxSpeed;
    }

    // ── Pick up ──────────────────────────────────────────────────────

    private void TryPickUp()
    {
        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        if (!Physics.Raycast(ray, out RaycastHit hit, 100f, placeableLayer))
            return;

        var placeable = hit.collider.GetComponent<PlaceableObject>();
        if (placeable == null)
            placeable = hit.collider.GetComponentInParent<PlaceableObject>();

        if (placeable == null || placeable.CurrentState == PlaceableObject.State.Held)
            return;

        _held = placeable;
        _heldRb = placeable.GetComponent<Rigidbody>();
        _heldRb.useGravity = false;
        _heldRb.isKinematic = false;
        _grabTarget = _heldRb.worldCenterOfMass;

        _currentSurface = placeable.LastPlacedSurface;
        _lastValidSurface = _currentSurface;
        _wallRotation = 0f;
        _isOnWall = false;

        placeable.OnPickedUp();
        ShowShadow(true);
    }

    // ── Place ────────────────────────────────────────────────────────

    private void Place()
    {
        if (_held == null) return;

        // Must be over a surface to place
        if (_currentSurface == null) return;

        // Can't place non-wallmount items on walls
        if (_currentSurface.IsVertical && !_held.CanWallMount) return;

        var hitResult = _currentSurface.ProjectOntoSurface(_heldRb.position);
        Vector3 pos = _gridSnap
            ? _currentSurface.SnapToGrid(hitResult.worldPosition, gridSize)
            : hitResult.worldPosition;

        // Offset along surface normal so object sits ON the surface
        float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
        pos += hitResult.surfaceNormal * halfExtent;

        // Compute rotation
        Quaternion rot;
        if (_currentSurface.IsVertical)
        {
            rot = Quaternion.LookRotation(-hitResult.surfaceNormal, Vector3.up)
                * Quaternion.AngleAxis(_wallRotation, Vector3.forward);
        }
        else
        {
            rot = _held.transform.rotation;
        }

        _heldRb.linearVelocity = Vector3.zero;
        _held.OnPlaced(_currentSurface, _gridSnap, pos, rot);
        _held = null;
        _heldRb = null;
        _currentSurface = null;
        _lastValidSurface = null;
        _isOnWall = false;
        ShowShadow(false);
    }

    // ── Grab target (surface raycast) ────────────────────────────────

    private void UpdateGrabTarget()
    {
        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        if (Physics.Raycast(ray, out RaycastHit hit, 100f, surfaceLayer))
        {
            var surface = hit.collider.GetComponentInParent<PlacementSurface>();
            if (surface != null)
            {
                // Skip vertical surfaces for non-wallmount objects
                if (surface.IsVertical && !_held.CanWallMount)
                {
                    _currentSurface = null;
                    _isOnWall = false;
                    return;
                }

                _currentSurface = surface;
                _lastValidSurface = surface;
                _isOnWall = surface.IsVertical;

                var hitResult = surface.ProjectOntoSurface(hit.point);
                Vector3 pos = _gridSnap
                    ? surface.SnapToGrid(hitResult.worldPosition, gridSize)
                    : hitResult.worldPosition;

                float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
                pos += hitResult.surfaceNormal * halfExtent;

                _grabTarget = pos;

                // Preview wall alignment
                if (_isOnWall)
                    _held.AlignToWall(hitResult.surfaceNormal, _wallRotation);

                return;
            }
        }

        // No surface hit — keep last grab target (object clings to last position)
        _currentSurface = null;
        _isOnWall = false;
    }

    // ── Scroll input ─────────────────────────────────────────────────

    private void UpdateScrollInput()
    {
        float scroll = _scrollAction.ReadValue<float>();
        if (Mathf.Abs(scroll) < 0.01f) return;

        if (_isOnWall)
        {
            // On wall: scroll adjusts rotation (straighten/tilt)
            _wallRotation += rotationStep * Mathf.Sign(scroll);
        }
        else
        {
            // On table: scroll rotates around Y
            _held.transform.Rotate(Vector3.up, rotationStep * Mathf.Sign(scroll), Space.World);
        }
    }

    // ── Helper: half-extent along a normal ────────────────────────────

    private float GetHeldHalfExtentAlongNormal(Vector3 normal)
    {
        var col = _held.GetComponent<Collider>();
        if (col == null) return 0f;

        Vector3 extents = col.bounds.extents;
        // Project extents onto normal direction
        return Mathf.Abs(Vector3.Dot(extents, normal.normalized));
    }

    // ── Shadow preview ──────────────────────────────────────────────

    private void BuildShadow()
    {
        _shadowGO = new GameObject("PlacementShadow");
        _shadowGO.transform.SetParent(transform);

        var mf = _shadowGO.AddComponent<MeshFilter>();
        _shadowRenderer = _shadowGO.AddComponent<MeshRenderer>();

        // Procedural quad
        var mesh = new Mesh { name = "ShadowQuad" };
        mesh.vertices = new[]
        {
            new Vector3(-0.5f, 0f, -0.5f),
            new Vector3( 0.5f, 0f, -0.5f),
            new Vector3( 0.5f, 0f,  0.5f),
            new Vector3(-0.5f, 0f,  0.5f)
        };
        mesh.uv = new[]
        {
            new Vector2(0f, 0f), new Vector2(1f, 0f),
            new Vector2(1f, 1f), new Vector2(0f, 1f)
        };
        mesh.triangles = new[] { 0, 2, 1, 0, 3, 2 };
        mesh.RecalculateNormals();
        mf.sharedMesh = mesh;

        // Procedural soft-circle texture
        int texSize = 32;
        var tex = new Texture2D(texSize, texSize, TextureFormat.RGBA32, false);
        tex.filterMode = FilterMode.Bilinear;
        tex.wrapMode = TextureWrapMode.Clamp;
        float center = texSize * 0.5f;
        float radius = center - 1f;
        for (int y = 0; y < texSize; y++)
        {
            for (int x = 0; x < texSize; x++)
            {
                float dist = Vector2.Distance(new Vector2(x, y), new Vector2(center, center));
                float a = Mathf.Clamp01((radius - dist) / 2f);
                tex.SetPixel(x, y, new Color(1f, 1f, 1f, a));
            }
        }
        tex.Apply();

        var shader = Shader.Find("Universal Render Pipeline/Particles/Unlit");
        if (shader == null) shader = Shader.Find("Sprites/Default");
        if (shader == null) shader = Shader.Find("Unlit/Transparent");
        _shadowMat = new Material(shader);
        _shadowMat.mainTexture = tex;
        _shadowMat.color = s_shadowValid;
        _shadowMat.SetFloat("_Surface", 1f); // Transparent
        _shadowMat.SetFloat("_Blend", 0f);   // Alpha
        _shadowMat.renderQueue = 3000;
        _shadowRenderer.sharedMaterial = _shadowMat;
        _shadowRenderer.shadowCastingMode = ShadowCastingMode.Off;
        _shadowRenderer.receiveShadows = false;

        _shadowGO.SetActive(false);
    }

    private void ShowShadow(bool show)
    {
        if (_shadowGO != null)
            _shadowGO.SetActive(show);
    }

    private void UpdateShadow()
    {
        if (_shadowGO == null || _heldRb == null) return;

        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        bool valid = false;
        Vector3 shadowPos = _heldRb.position + Vector3.down * 0.5f;
        Quaternion shadowRot = Quaternion.identity;
        Vector3 surfaceNormal = Vector3.up;

        if (Physics.Raycast(ray, out RaycastHit hit, 100f, surfaceLayer))
        {
            var surface = hit.collider.GetComponentInParent<PlacementSurface>();
            if (surface != null)
            {
                bool canPlace = !surface.IsVertical || _held.CanWallMount;
                var hitResult = surface.ProjectOntoSurface(hit.point);
                shadowPos = hitResult.worldPosition + hitResult.surfaceNormal * 0.01f;
                surfaceNormal = hitResult.surfaceNormal;
                shadowRot = Quaternion.FromToRotation(Vector3.up, surfaceNormal);
                valid = canPlace;
            }
        }

        _shadowMat.color = valid ? s_shadowValid : s_shadowInvalid;
        _shadowGO.transform.position = shadowPos;
        _shadowGO.transform.rotation = shadowRot;

        // Scale to match held object's footprint
        var col = _held.GetComponent<Collider>();
        if (col != null)
        {
            Vector3 ext = col.bounds.extents;
            float diameter = Mathf.Max(ext.x, ext.z) * 2f;
            _shadowGO.transform.localScale = new Vector3(diameter, 1f, diameter);
        }
    }

    // ── Public API ──────────────────────────────────────────────────

    /// <summary>
    /// Enable or disable grabbing. Called by ApartmentManager during state transitions.
    /// When disabled while holding, forces a drop onto the nearest surface.
    /// </summary>
    public void SetEnabled(bool enabled)
    {
        _isEnabled = enabled;

        if (!enabled && _held != null)
        {
            // Force-drop onto nearest surface instead of letting it fall into void
            var nearest = FindNearestSurface(_heldRb.position);
            if (nearest != null)
            {
                var hitResult = nearest.ProjectOntoSurface(_heldRb.position);
                float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
                Vector3 pos = hitResult.worldPosition + hitResult.surfaceNormal * halfExtent;
                Quaternion rot = nearest.IsVertical
                    ? Quaternion.LookRotation(-hitResult.surfaceNormal, Vector3.up)
                    : _held.transform.rotation;

                _heldRb.linearVelocity = Vector3.zero;
                _held.OnPlaced(nearest, false, pos, rot);
            }
            else
            {
                // No surface found — just drop with gravity
                _heldRb.useGravity = true;
                _heldRb.linearVelocity = Vector3.zero;
                _held.OnDropped();
            }

            _held = null;
            _heldRb = null;
            _currentSurface = null;
            _lastValidSurface = null;
            _isOnWall = false;
            ShowShadow(false);
        }
    }

    private PlacementSurface FindNearestSurface(Vector3 worldPos)
    {
        var allSurfaces = FindObjectsByType<PlacementSurface>(FindObjectsSortMode.None);
        PlacementSurface best = null;
        float bestDist = float.MaxValue;

        foreach (var surface in allSurfaces)
        {
            if (surface == null) continue;
            Vector3 clamped = surface.ClampToSurface(worldPos);
            float dist = (clamped - worldPos).sqrMagnitude;
            if (dist < bestDist)
            {
                bestDist = dist;
                best = surface;
            }
        }

        return best;
    }
}
