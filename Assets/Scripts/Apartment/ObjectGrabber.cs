using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.Rendering;

public class ObjectGrabber : MonoBehaviour
{
    [Header("Physics")]
    [Tooltip("Spring strength pulling the object toward the cursor.")]
    [SerializeField] private float grabSpring = 120f;

    [Tooltip("Damper opposing overshoot.")]
    [SerializeField] private float grabDamper = 18f;

    [Tooltip("Maximum acceleration applied to the grabbed object.")]
    [SerializeField] private float maxAccel = 60f;

    [Tooltip("Maximum speed cap to prevent tunneling.")]
    [SerializeField] private float maxSpeed = 12f;

    [Header("Grid Snap")]
    [Tooltip("Grid cell size in world units.")]
    [SerializeField] private float gridSize = 0.2f;

    [Header("Scroll Behavior")]
    [Tooltip("World units moved per scroll tick on Y axis.")]
    [SerializeField] private float scrollHeightStep = 0.05f;

    [Header("Raycast")]
    [Tooltip("Layer mask for placeable objects.")]
    [SerializeField] private LayerMask placeableLayer = ~0;

    [Tooltip("Layer mask for surface triggers (auto-generated by PlacementSurface).")]
    [SerializeField] private LayerMask surfaceLayer;

    [Tooltip("Camera used for raycasting. Auto-finds MainCamera if null.")]
    [SerializeField] private Camera cam;

    [Header("Tether")]
    [Tooltip("Max distance between grab target and held object before teleporting to catch up.")]
    [SerializeField] private float maxTetherDistance = 3f;

    // Inline InputActions
    private InputAction _mousePosition;
    private InputAction _mouseClick;
    private InputAction _gridToggle;
    private InputAction _scrollAction;

    private bool _isEnabled;
    private bool _gridSnap;

    private static ObjectGrabber s_instance;

    /// <summary>True when any ObjectGrabber is holding an object. Check this to block other interactions.</summary>
    public static bool IsHoldingObject => s_instance != null && s_instance._held != null;

    private PlaceableObject _held;
    private Rigidbody _heldRb;
    private Vector3 _grabTarget;
    private float _fallbackDepth;
    private RigidbodyConstraints _originalConstraints;

    // Surface tracking
    private PlacementSurface _currentSurface;
    private PlacementSurface _lastValidSurface;
    private float _wallRotation;
    private bool _isOnWall;

    // Shadow preview
    private GameObject _shadowGO;
    private MeshRenderer _shadowRenderer;
    private Material _shadowMat;
    private static readonly Color s_shadowValid = new Color(0.2f, 0.8f, 0.3f, 0.5f);
    private static readonly Color s_shadowInvalid = new Color(0.8f, 0.2f, 0.2f, 0.5f);

    private void Awake()
    {
        s_instance = this;

        if (cam == null)
            cam = Camera.main;

        _mousePosition = new InputAction("MousePos", InputActionType.Value, "<Mouse>/position");
        _mouseClick = new InputAction("MouseClick", InputActionType.Button, "<Mouse>/leftButton");
        _gridToggle = new InputAction("GridToggle", InputActionType.Button, "<Keyboard>/g");
        _scrollAction = new InputAction("Scroll", InputActionType.Value, "<Mouse>/scroll/y");

        BuildShadow();
    }

    private void OnEnable()
    {
        _mousePosition.Enable();
        _mouseClick.Enable();
        _gridToggle.Enable();
        _scrollAction.Enable();
    }

    private void OnDisable()
    {
        _mousePosition.Disable();
        _mouseClick.Disable();
        _gridToggle.Disable();
        _scrollAction.Disable();
    }

    private void OnDestroy()
    {
        if (s_instance == this) s_instance = null;
        if (_shadowMat != null) Destroy(_shadowMat);
    }

    private void Update()
    {
        if (DayPhaseManager.Instance != null && !DayPhaseManager.Instance.IsInteractionPhase)
            return;

        if (!_isEnabled) return;

        if (_gridToggle.WasPressedThisFrame())
        {
            _gridSnap = !_gridSnap;
            Debug.Log($"[ObjectGrabber] Grid snap: {(_gridSnap ? "ON" : "OFF")}");
        }

        if (_mouseClick.WasPressedThisFrame())
        {
            if (_held == null)
                TryPickUp();
            else
                Place();
        }

        if (_held != null)
        {
            UpdateGrabTarget();
            UpdateScrollInput();
            UpdateShadow();
        }
    }

    private void FixedUpdate()
    {
        if (_held == null || _heldRb == null) return;

        // Tether snap-back
        if (Vector3.Distance(_heldRb.position, _grabTarget) > maxTetherDistance)
        {
            _heldRb.position = _grabTarget;
            _heldRb.linearVelocity = Vector3.zero;
        }

        // Spring-damper pull
        Vector3 toTarget = _grabTarget - _heldRb.worldCenterOfMass;
        Vector3 accel = toTarget * grabSpring - _heldRb.linearVelocity * grabDamper;

        if (accel.sqrMagnitude > maxAccel * maxAccel)
            accel = accel.normalized * maxAccel;

        _heldRb.AddForce(accel, ForceMode.Acceleration);

        // Speed cap
        if (_heldRb.linearVelocity.sqrMagnitude > maxSpeed * maxSpeed)
            _heldRb.linearVelocity = _heldRb.linearVelocity.normalized * maxSpeed;
    }

    // ── Pick up ──────────────────────────────────────────────────────

    private void TryPickUp()
    {
        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        if (!Physics.Raycast(ray, out RaycastHit hit, 100f, placeableLayer))
            return;

        var placeable = hit.collider.GetComponent<PlaceableObject>();
        if (placeable == null)
            placeable = hit.collider.GetComponentInParent<PlaceableObject>();

        if (placeable == null || placeable.CurrentState == PlaceableObject.State.Held)
            return;

        _held = placeable;

        // Detach from plate stack before pickup
        var stackable = placeable.GetComponent<StackablePlate>();
        if (stackable != null)
            stackable.PrepareForGrab();

        _heldRb = placeable.GetComponent<Rigidbody>();
        _heldRb.useGravity = false;
        _heldRb.isKinematic = false;
        _grabTarget = _heldRb.worldCenterOfMass;

        // Store depth for floating fallback when cursor isn't over a surface
        _fallbackDepth = Vector3.Dot(
            _heldRb.worldCenterOfMass - cam.transform.position,
            cam.transform.forward);

        // Lock rotation so collisions don't spin the object
        _originalConstraints = _heldRb.constraints;
        _heldRb.constraints = _originalConstraints | RigidbodyConstraints.FreezeRotation;

        _currentSurface = placeable.LastPlacedSurface;
        _lastValidSurface = _currentSurface;
        _wallRotation = 0f;
        _isOnWall = false;

        placeable.OnPickedUp();
        ShowShadow(true);
    }

    // ── Place ────────────────────────────────────────────────────────

    private void Place()
    {
        if (_held == null) return;

        // Must be over a surface to place
        if (_currentSurface == null) return;

        // Wall items only on walls, table items only on tables
        if (_currentSurface.IsVertical && !_held.CanWallMount) return;
        if (!_currentSurface.IsVertical && _held.WallOnly) return;

        var hitResult = _currentSurface.ProjectOntoSurface(_heldRb.position);
        Vector3 pos = _gridSnap
            ? _currentSurface.SnapToGrid(hitResult.worldPosition, gridSize)
            : hitResult.worldPosition;

        float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
        pos += hitResult.surfaceNormal * halfExtent;

        Quaternion rot;
        if (_currentSurface.IsVertical)
        {
            rot = Quaternion.LookRotation(-hitResult.surfaceNormal, Vector3.up)
                * Quaternion.AngleAxis(_wallRotation, Vector3.forward);
        }
        else
        {
            rot = _held.transform.rotation;
        }

        // Restore constraints before placement configures the rigidbody
        _heldRb.constraints = _originalConstraints;
        _heldRb.linearVelocity = Vector3.zero;

        _held.OnPlaced(_currentSurface, _gridSnap, pos, rot);

        // Stack-aware plate hooks
        var stackable = _held.GetComponent<StackablePlate>();
        if (stackable != null)
        {
            stackable.TryJoinStack();
            var dropZone = _currentSurface != null
                ? _currentSurface.GetComponent<DishDropZone>() : null;
            if (dropZone != null)
                dropZone.RegisterDeposit(stackable);
        }

        _held = null;
        _heldRb = null;
        _currentSurface = null;
        _lastValidSurface = null;
        _isOnWall = false;
        ShowShadow(false);
    }

    // ── Grab target (surface raycast with depth-plane fallback) ──────

    private void UpdateGrabTarget()
    {
        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        // During dolly animation, keep object on screen-space depth plane
        // so it travels with the cursor instead of clinging to the old room
        bool dollying = ApartmentManager.Instance != null && ApartmentManager.Instance.IsTransitioning;

        if (!dollying && Physics.Raycast(ray, out RaycastHit hit, 100f, surfaceLayer))
        {
            var surface = hit.collider.GetComponentInParent<PlacementSurface>();
            bool surfaceValid = surface != null
                && (!surface.IsVertical || _held.CanWallMount)
                && (surface.IsVertical || !_held.WallOnly);
            if (surfaceValid)
            {
                _currentSurface = surface;
                _lastValidSurface = surface;
                _isOnWall = surface.IsVertical;

                var hitResult = surface.ProjectOntoSurface(hit.point);
                Vector3 pos = _gridSnap
                    ? surface.SnapToGrid(hitResult.worldPosition, gridSize)
                    : hitResult.worldPosition;

                float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
                pos += hitResult.surfaceNormal * halfExtent;

                _grabTarget = pos;

                // Track depth so fallback stays smooth if cursor leaves surface
                _fallbackDepth = Vector3.Dot(
                    _grabTarget - cam.transform.position,
                    cam.transform.forward);

                if (_isOnWall)
                    _held.AlignToWall(hitResult.surfaceNormal, _wallRotation);

                return;
            }
        }

        // No valid surface or dollying — float at fallback depth following cursor
        _currentSurface = null;
        _isOnWall = false;

        Vector3 planePoint = cam.transform.position + cam.transform.forward * _fallbackDepth;
        var plane = new Plane(-cam.transform.forward, planePoint);
        if (plane.Raycast(ray, out float enter))
            _grabTarget = ray.GetPoint(enter);
    }

    // ── Scroll input ─────────────────────────────────────────────────

    private void UpdateScrollInput()
    {
        float scroll = _scrollAction.ReadValue<float>();
        if (Mathf.Abs(scroll) < 0.01f) return;

        // Scroll moves the grab target up/down on Y
        _grabTarget.y += scrollHeightStep * Mathf.Sign(scroll);
    }

    // ── Helper: half-extent along a normal ────────────────────────────

    private const float PlacementSafetyMargin = 0.02f;

    private float GetHeldHalfExtentAlongNormal(Vector3 normal)
    {
        var col = _held.GetComponent<Collider>();
        if (col == null) return 0f;

        Vector3 extents = col.bounds.extents;
        return Mathf.Abs(Vector3.Dot(extents, normal.normalized)) + PlacementSafetyMargin;
    }

    // ── Shadow preview ──────────────────────────────────────────────

    private void BuildShadow()
    {
        _shadowGO = new GameObject("PlacementShadow");
        _shadowGO.transform.SetParent(transform);

        var mf = _shadowGO.AddComponent<MeshFilter>();
        _shadowRenderer = _shadowGO.AddComponent<MeshRenderer>();

        var mesh = new Mesh { name = "ShadowQuad" };
        mesh.vertices = new[]
        {
            new Vector3(-0.5f, 0f, -0.5f),
            new Vector3( 0.5f, 0f, -0.5f),
            new Vector3( 0.5f, 0f,  0.5f),
            new Vector3(-0.5f, 0f,  0.5f)
        };
        mesh.uv = new[]
        {
            new Vector2(0f, 0f), new Vector2(1f, 0f),
            new Vector2(1f, 1f), new Vector2(0f, 1f)
        };
        mesh.triangles = new[] { 0, 2, 1, 0, 3, 2 };
        mesh.RecalculateNormals();
        mf.sharedMesh = mesh;

        int texSize = 32;
        var tex = new Texture2D(texSize, texSize, TextureFormat.RGBA32, false);
        tex.filterMode = FilterMode.Bilinear;
        tex.wrapMode = TextureWrapMode.Clamp;
        float center = texSize * 0.5f;
        float radius = center - 1f;
        for (int y = 0; y < texSize; y++)
        {
            for (int x = 0; x < texSize; x++)
            {
                float dist = Vector2.Distance(new Vector2(x, y), new Vector2(center, center));
                float a = Mathf.Clamp01((radius - dist) / 2f);
                tex.SetPixel(x, y, new Color(1f, 1f, 1f, a));
            }
        }
        tex.Apply();

        var shader = Shader.Find("Universal Render Pipeline/Particles/Unlit");
        if (shader == null) shader = Shader.Find("Sprites/Default");
        if (shader == null) shader = Shader.Find("Unlit/Transparent");
        _shadowMat = new Material(shader);
        _shadowMat.mainTexture = tex;
        _shadowMat.color = s_shadowValid;
        _shadowMat.SetFloat("_Surface", 1f);
        _shadowMat.SetFloat("_Blend", 0f);
        _shadowMat.renderQueue = 3000;
        _shadowRenderer.sharedMaterial = _shadowMat;
        _shadowRenderer.shadowCastingMode = ShadowCastingMode.Off;
        _shadowRenderer.receiveShadows = false;

        _shadowGO.SetActive(false);
    }

    private void ShowShadow(bool show)
    {
        if (_shadowGO != null)
            _shadowGO.SetActive(show);
    }

    private void UpdateShadow()
    {
        if (_shadowGO == null || _heldRb == null) return;

        Vector2 screenPos = _mousePosition.ReadValue<Vector2>();
        Ray ray = cam.ScreenPointToRay(screenPos);

        bool valid = false;
        Vector3 shadowPos = _heldRb.position + Vector3.down * 0.5f;
        Quaternion shadowRot = Quaternion.identity;

        if (Physics.Raycast(ray, out RaycastHit hit, 100f, surfaceLayer))
        {
            var surface = hit.collider.GetComponentInParent<PlacementSurface>();
            if (surface != null)
            {
                bool canPlace = (!surface.IsVertical || _held.CanWallMount)
                    && (surface.IsVertical || !_held.WallOnly);
                var hitResult = surface.ProjectOntoSurface(hit.point);
                shadowPos = hitResult.worldPosition + hitResult.surfaceNormal * 0.01f;
                shadowRot = Quaternion.FromToRotation(Vector3.up, hitResult.surfaceNormal);
                valid = canPlace;
            }
        }

        _shadowMat.color = valid ? s_shadowValid : s_shadowInvalid;
        _shadowGO.transform.position = shadowPos;
        _shadowGO.transform.rotation = shadowRot;

        var col = _held.GetComponent<Collider>();
        if (col != null)
        {
            Vector3 ext = col.bounds.extents;
            float diameter = Mathf.Max(ext.x, ext.z) * 2f;
            _shadowGO.transform.localScale = new Vector3(diameter, 1f, diameter);
        }
    }

    // ── Public API ──────────────────────────────────────────────────

    /// <summary>
    /// Enable or disable grabbing. Called by ApartmentManager during state transitions.
    /// When disabled while holding, forces a drop onto the nearest surface.
    /// </summary>
    public void SetEnabled(bool enabled)
    {
        _isEnabled = enabled;

        if (!enabled && _held != null)
        {
            // Restore rotation constraints before configuring rigidbody
            _heldRb.constraints = _originalConstraints;

            var nearest = FindNearestSurfaceForHeld(_heldRb.position);
            if (nearest != null)
            {
                var hitResult = nearest.ProjectOntoSurface(_heldRb.position);
                float halfExtent = GetHeldHalfExtentAlongNormal(hitResult.surfaceNormal);
                Vector3 pos = hitResult.worldPosition + hitResult.surfaceNormal * halfExtent;
                Quaternion rot = nearest.IsVertical
                    ? Quaternion.LookRotation(-hitResult.surfaceNormal, Vector3.up)
                    : _held.transform.rotation;

                _heldRb.linearVelocity = Vector3.zero;
                _held.OnPlaced(nearest, false, pos, rot);

                // Stack-aware plate hooks on force-drop
                var stackable = _held.GetComponent<StackablePlate>();
                if (stackable != null)
                {
                    stackable.TryJoinStack();
                    var dropZone = nearest.GetComponent<DishDropZone>();
                    if (dropZone != null)
                        dropZone.RegisterDeposit(stackable);
                }
            }
            else
            {
                _heldRb.useGravity = true;
                _heldRb.linearVelocity = Vector3.zero;
                _held.OnDropped();
            }

            _held = null;
            _heldRb = null;
            _currentSurface = null;
            _lastValidSurface = null;
            _isOnWall = false;
            ShowShadow(false);
        }
    }

    private PlacementSurface FindNearestSurfaceForHeld(Vector3 worldPos)
    {
        if (_held == null) return PlacementSurface.FindNearest(worldPos);
        return PlacementSurface.FindNearest(worldPos,
            skipVertical: !_held.CanWallMount,
            skipHorizontal: _held.WallOnly);
    }
}
